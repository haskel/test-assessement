## Как запустить
1. Чтобы сбилдить docker-контейнеры, и выполнить миграции, нужно выполнить команду:
```bash
make dev.up.build
```
2. Чтобы запустить тесты:
```bash
make test
```
3. Чтобы запустить пример собранного приложения:
```bash
make dev.run
```
4. Чтобы попасть в контейнер:
```bash
make dev.console
```
5. Чтобы остановить контейнеры:
```bash
make dev.down
```
6. Чтобы опять поднять контейнеры:
```bash
make dev.up
```

## Пояснение к решению
- Логирование изменений в юзере я реализовал через лисенер, а также допустил ситуацию, при которой логирование может не произойти, даже если изменения произошли успешно.
  Как такую ситуацию разрешать - это отдельный интересный разговор, который зависит от бизнес-логики.
- Приоритет у лисенера, отвечающего за логирование изменений, самый высокий для того, чтобы не столкнуться с модификацией объекта юзера, которая будет произведена после его сохранения
- Для валидации модели использовалась библиотека `symfony/validator` с готовыми атрибутами.
  Это симпатичное решение, им приятно пользоваться, но для скорости работы нужно добавлять кеширование в проде, этот момент я не реализовывал
- Валидация уникальности name и email в моем решении разделены, но для экономии запросов в БД вцелом можно их объединить.
  Можно даже пойти еще дальше и если мы экономим запросы, то можно расчитывать на ошибку от БД.
- Репозиторий юзеров я сделал довольно простым, валидацию я вынес на уровень выше в сервис, дав возможность репозиторию работать с невалидными объектами.
  Я выбрал смешаное решение, при котором частичная валидация происходит на уровне модели, а полная (связанная с бизнес логикой) на уровне сервиса.
- Поля модели я сделал nullable, что не всегда хорошо, но здесь это решается на уровне валидации
- Сервисы для проверки запрещенных слов и доменов в большом проекте скорей всего будут здекларированы через интерфейсы,
  чтобы развязать реализацию, но в текущей задаче я опустил этот момент. Это всегда можно сделать в тот момент, когда появляется вторая реализация.
  А с современными IDE рефакторинг будет мгновенный.
- Простановку как даты создания, так и даты удаления я сделал в коде, а не в базе данных, это позволяет гибче работать с таймзонами, но это обсуждаемо
- Чтобы в будущем все soft-delete модели имели общий подход, я добавил интерфейс `SoftDeletableInterface` (возможно это преждевременно)
- Тесты по группам не делил, потому что их мало, и пока неясно как и делить
- Сквозной тест на проверку логирования в случае успешного обновления юзера я не писал, но вообще это может быть полезно
- Тесты на некоторые валидаторы не дописал, уже притомился, но из других тестов можно понять общий подход
- Логирование ошибок не реализовывал, предполагая, что оно уровнем выше
- Для упрощения в сервисе UserService не использовались DTO, а использовались обычные массивы
